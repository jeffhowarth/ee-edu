{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ee pattern book","text":"<p>A collection of timeless problems of spatial analysis and image processing and how to solve them with Google Earth Engine.      </p> <p>Jeff Howarth Associate Professor of Geography  Geography Department Middlebury College Vermont, USA</p> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"geoMethods/","title":"geoMethods","text":"<p>geoMethods is a collection of, well, methods that I wrote and packaged in a way that will allow you to use the methods without having to write them from scratch. </p> <p>I wrote these methods for two reasons:    </p> <ol> <li> <p>Each represents a recurring task of geospatial analysis that are supported by other geographic information systems (like QGIS or ArcGIS).</p> </li> <li> <p>Each requires a chain of transformations to make in Earth Engine which can be conceptually confusing and technically difficult for novices to do.    </p> </li> </ol> <p>My hope is that providing ready-made methods may help you focus on how different methods of spatial analysis and cartography work conceptually in workflows without having to get bogged down in writing complicated task chains for common tools.  </p>"},{"location":"geoMethods/#import-module","title":"import module","text":"<p>To use geoMethods, create a container and require the module. </p> <pre><code>var geo = require(\"users/jhowarth/eePatterns:modules/geoMethods.js\");\n\nprint(\"geoMethods dictionary\", geo.help);    // Prints dictionary of all tools in module.\n</code></pre> <p>The code block above will import the module and print the module\u2019s help dictionary, which lists all methods and url links to their docs. You only need to import the module once in a script the calls method in the module. I usually place the above code near the top of my script (under the header).  </p>"},{"location":"geoMethods/#docs-in-eepatterns","title":"docs in eePatterns","text":"<p>A globe icon  identifies methods from module. </p> <p>In the METHODS documentation, the  symbol identifies a method that requires the geoMethods module. To use any of these methods, you will need to include the import module in your script prior to calling the method. </p>"},{"location":"geoMethods/#peak-under-hood","title":"peak under hood","text":"<p>Add module to your READER tray if you want to see the underlying code to any method.</p> <p>The module only hides the data from you if you do not want to see it. If you would like to look under the hood, I have made the code for the module public and you can add it to the READER tray of the IDE by clicking here. </p> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"intro/","title":"introduction","text":"<p>This book aims to help you create geospatial workflows with Google Earth Engine.  </p> <p>In general, these workflows grab geographic data stored in the cloud, alter it (with purpose), and then visualize the results as map layers.  </p> <p> <pre><code>graph LR\n  step01[(\"GEOGRAPHIC\\nDATA\\n\\n stored in cloud\")] ;\n  step02&gt;\"GEOSPATIAL WORKFLOW\\n\\n alter and visualize\"] ;\n\n  step01 --&gt; step02\n\n  classDef store fill:#4AA8A0,stroke-width:0px,color:#FFFFFF; \n  classDef transform fill:#4A92A8,stroke-width:0px,color:#FFFFFF;\n\n  class step01 store; \n  class step02 transform;\n\n</code></pre> <p></p> <p>To do this, we will use a web-based Integrated Development Environment (IDE) for the Earth Engine Javascript Application Programming Interface (API). That is a mouthful, but in practical terms it means that we will create workflows by writing scripts with javascript.   </p>"},{"location":"intro/#data-transformation","title":"data transformation","text":"<p>The basic element of all geospatial workflows is a three step process that Waldo Tobler called a cartographic transformation: you start with geographic data in a certain state (input), you do something to alter the data (method), and you store the result (output). Often but not always, one or more options (arguments) constrain how a method alters the input.   </p> <p> <pre><code>graph LR\n\n  input[\"INPUT\"] ;\n  method(\"METHOD\") ;\n  output[/\"OUTPUT\"/]  ;\n\n  input --&gt; method --&gt; output\n\n  arg[\"argument\"] ;\n\n  arg --o method\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class input in-out; \n  class method op;\n  class output in-out;\n  class arg arg; </code></pre> <p></p>"},{"location":"intro/#statements","title":"statements","text":"<p>With JavaScript, we transform geographic data by writing a statement. The syntax generally takes this form:</p> <pre><code>var output = input.method(argument);\n</code></pre> <p>The general pattern is that you start by defining a name for a container that you would like to make so that you can store the output. This container of data is called a variable that you create with the keyword <code>var</code>. You then say that this container will contain <code>=</code> what results from taking the input and applying a method to it <code>.</code> with one or more arguments <code>()</code>. A semicolon <code>;</code> punctuates a statement like a period (or wink ).  </p>"},{"location":"intro/#task-trees","title":"task trees","text":"<p>Workflows are a means to achieving an end. When you sit down to write a workflow, you have some goal state for the data in mind. Your problem is to figure out how to change the data from their original condition to the goal state in your head.  </p> <p>Most workflows can be decomposed into a task trees: at the top, a (big) problem  may be broken down into a sequence of smaller tasks, each of these tasks may be broken down into smaller subtasks.    </p> <pre><code>graph TD\n\n  L01(\"PROBLEM\") ;\n  L11[\"TASK 1\"] ;\n  L12[\"TASK 2\"] ;\n  L21[\"SUBTASK 1\"] ;\n  L22[\"SUBTASK 2\"] ;\n  L23[\"SUBTASK 3\"] ;\n  L24[\"SUBTASK 4\"] ;\n\n  L01 --- L11 \n  L01 --- L12\n  L11 --- L21\n  L11 --- L22\n  L12 --- L23\n  L12 --- L24\n\n  classDef L0 fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef L1 fill:#CCCCCC,stroke-width:0px,color:#000000;\n  classDef L2 fill:#000000,stroke-width:0px,color:#FFFFFF;  \n\n  class L01 L0; \n  class L11 L1;\n  class L12 L1;\n  class L21 L2;\n  class L22 L2;\n  class L23 L2;\n  class L24 L2;\n\n</code></pre> <p></p>"},{"location":"intro/#task-chains","title":"task chains","text":"<p>The lowest branches of the tree are individual transformations, the foundational elements of a workflow. Higher branches of the tree often require linking together two or more transformations in task chains, where the output of one transformation becomes the input of another. </p> <p> <pre><code>graph LR\n  step01(\"INPUT\") ;\n  step02[\"METHOD\"] ;\n  step03(\"OUTPUT\")  ;\n  step04[\"METHOD_2\"] ;\n  step05(\"OUTPUT_2\")  ;\n  arg01(\"argument\") ;\n  arg02(\"argument_2\") ;\n\n  step01 --&gt; step02 --&gt; step03 --&gt; step04 --&gt; step05\n  arg01 --- step02\n  arg02 --- step04\n\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class step01 in-out; \n  class step02 op;\n  class step03 in-out;\n  class step04 op;\n  class step05 in-out;\n  class arg01 arg;\n  class arg02 arg;\n\n</code></pre> <p></p>"},{"location":"intro/#summary","title":"summary","text":"<p>If this all sounds a bit wonky, do not worry too much. We will get to examples that illustrate all of this soon. For now, I just want you to know:  </p> <ol> <li>a workflow is a chain of input-method-output transformations </li> <li>you can think of a workflow visually (as a flow diagram) and verbally (as javascript).  </li> <li>visually, a workflow contains a vertical hierarchy of purpose (task tree) and a horizontal sequence of transformations (task chains). </li> </ol> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/customize-Map/","title":"customize Map","text":"<p>It is often helpful to customize the Map so that it centers and zooms on your area of interest and uses a base map that supports your purpose.  </p> <p>The diagram below shows a general pattern.</p> <p> <pre><code>graph LR\n\n  step01(\"Set map center and zoom\") ;\n  step02(\"Set base map style\") ;\n\n  step01 --&gt; step02\n\n  classDef task fill:#C3C8E6,stroke-width:0px,color:#000000;\n\n  class step01 task; \n  class step02 task;\n</code></pre> <p></p> <p>It is good practice to set the map center and zoom level before setting the base map so that the base map does not need to redraw.</p>"},{"location":"methods/customize-Map/#set-map-center-and-zoom","title":"set map center and zoom","text":"<p>Use a data object to center the map and to suggest an appropriate zoom level. </p> <pre><code>Map.centerObject(\nimage,              // data object\n16                  // zoom level\n);\n</code></pre>"},{"location":"methods/customize-Map/#set-basemap-style","title":"set basemap style","text":"<p>Select a basemap that provides the most helpful reference information from your data. </p> <pre><code>Map.setOptions(\"HYBRID\");\n</code></pre> <p>Choose from the following options: </p> <p><pre><code>\"ROADMAP\" </code></pre> <pre><code>\"SATELLITE\" </code></pre> <pre><code>\"HYBRID\"\n</code></pre> <pre><code>\"TERRAIN\" </code></pre></p>"},{"location":"methods/explain-code/","title":"explain code","text":"<p>Always write your code for two main audiences: </p> <ol> <li>a computer that will compile and execute your code;</li> <li>a person who will read your code and try to make sense of it. </li> </ol> <p>The second audience may be yourself in the future, when you return to a script that you wrote after some time has passed. It may be an instructor in this course who wants to help you troubleshoot something in your script that is not working. Or it may be someone you have never met who is looking to adapt and recycle parts of your script for a slightly different purpose. Whoever the reader may be, you should always aim to help people read your code by placing explanations directly in your workflow. </p> <p>The patterns below describe different ways to explain your code and make it more readable for a human audience. </p>"},{"location":"methods/explain-code/#script-header","title":"script header","text":"<p>Write a header at the top of your script.</p> <p>At a minimum, the header should identify who wrote the script, when they wrote it, and why they wrote it. This is also where many authors will define the license for the script.  </p> <p>I usually include a couple lines of repeating symbols to visually block the header and separate it from the rest of the script.  </p> <pre><code>/*    \n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    AUTHOR:   \n    DATE:     \n    TITLE:  \n\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n*/\n</code></pre>"},{"location":"methods/explain-code/#task-description","title":"task description","text":"<p>Write a line comment before each major task in your workflow.</p> <p>Describe what you are doing or why you are doing it. Use full sentences and correct punctuation (start each comment with a capital letter and end each comment with a period).  </p> <p>I usually include a line of repeating symbols above and below the task description to help visually separate the code into discrete chunks.  </p> <pre><code>// -------------------------------------------------------------\n//  To illustrate a task description.\n// -------------------------------------------------------------\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/gather-raster-data/","title":"gather raster data","text":"<p>One of the first things you will usually do with Earth Engine is gather some data from the cloud. Before we get too deep into this, we should review the basic templates for storing geographic data (geographic data models) and how they are implemented in Earth Engine.     </p>"},{"location":"methods/gather-raster-data/#raster-data-model","title":"raster data model","text":"<p>A raster stores geographic data with a grid of pixels. Each pixel, or cell in the grid, stores a value as a digital number. The data type defines the length of binary numbers used to store the digital number. In the diagram below, the values shown on the left can be stored as a 8 bit unsigned integer, or byte, data type shown on the right. </p> <p></p>"},{"location":"methods/gather-raster-data/#image-data-object","title":"image data object","text":"<p>In Earth Engine, the raster model underlies the image data object, where an image is composed of one or more bands and each band is a raster.  </p> <p></p>"},{"location":"methods/gather-raster-data/#accessing-images-from-cloud","title":"accessing images from cloud","text":"<p>The diagram below shows a typical pattern for accessing cloud data.</p> <p> <pre><code>graph LR\n\n  step01(\"Construct from address\") ;\n  step02(\"Inspect data object\") ;\n\n  step01 --&gt; step02\n\n  classDef task fill:#C9C3E6,stroke-width:0px,color:#000000;\n\n  class step01 task; \n  class step02 task;\n</code></pre> <p></p> <p>The pattern is to first construct the object and then immediately inspect the properties of the object.  </p>"},{"location":"methods/gather-raster-data/#construct-image-from-address","title":"construct image from address","text":"<p>Use the <code>ee.Image()</code> method to construct an image from the cloud. This method takes the address for the data asset as an argument.   </p> <p> <pre><code>graph LR\n  step02(\"ee.Image()\") ;\n  step03[/\"image\"/]  ;\n  arg01[\"'address/of/cloud/data'\"] ;\n\n  step02 --&gt; step03\n  arg01 --o step02\n\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class step01 in-out; \n  class step02 op;\n  class step03 in-out;\n  class arg01 arg; </code></pre> <p></p> <p>To adapt the snippet below, you will just need to replace <code>'address/of/cloud/data'</code> with the data address. The address must be a string.  </p> <pre><code>var image = ee.Image('address/of/cloud/data');\n</code></pre>"},{"location":"methods/gather-raster-data/#inspect-data-properties","title":"inspect data properties","text":"<p>After constructing or altering a data object, I usually want to quickly familiarize myself the properties of the data. To do this, use the <code>print()</code> method to print the properties of the data object to the Console.  </p> <pre><code>print(\n\"A helpful label\",\nimage\n)\n;\n</code></pre> <p>To adapt the snippet below, replace <code>\"A helpful label\"</code> with a label that describes the image you are working with. This label must be a string. As necessary, replace <code>image</code> in the following line with the name of the variable that contains the image data.  </p>"},{"location":"methods/gather-raster-data/#full-pattern","title":"full pattern","text":"<p>Here are the two parts of the pattern together.</p> <pre><code>var image = ee.Image('address/of/cloud/data');\n\nprint(\n\"A helpful label\",\nimage\n)\n;\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/javascript/","title":"JavaScript","text":"<p>Here are some basic patterns for writing in JavaScript.</p>"},{"location":"methods/javascript/#comments","title":"comments","text":"<p>Use comments to explain your code.</p> <pre><code>// Line comments start with two forward slashes. Like this line. \n\n/* Multi-line comments start with a forward slash and a star,\nand end with a star and a forward slash. */ </code></pre>"},{"location":"methods/javascript/#variables","title":"variables","text":"<p>Use variables to contain (hold, store) data. </p> <pre><code>// Write a statement using the keyword var.\n\nvar hello = 'Hello world';    // Statements should end in a semi-colon, or else the Code Editor complains.\n\nvar test = \"I feel incomplete...\"\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// !! Variable names cannot contain spaces or - dashes - !!\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n// Use underscores to separate words in variable names.\n\nvar this_is_called_snake_case = 'Hello, snake!';\n\n// Or use capitalizations to separate words:\n\nvar thisIsCalledCamelCase = 'Hello, camel!';\n</code></pre>"},{"location":"methods/javascript/#print-to-console","title":"print to console","text":"<p>Use print function to print contents of variables and objects to console. </p> <pre><code>// Use parenthesis to pass arguments to print function.  \n\nprint(hello);\n\n// Use commas to pass multiple arguments. \n\nprint('Print test', hello);\n</code></pre>"},{"location":"methods/javascript/#strings","title":"strings","text":"<p>Use strings to store text (character strings). </p> <pre><code>// Use single quotes to define string.\n\nvar hello = \"Hello world!\"  // This is a string. \n\n// You can also use double quotes to enclose string.\n\nvar obi_one = \"Hello there\";\n\n// Just do not mix them.\n\nvar cranky = \"Hello Newman';  // This will throw an error. You will need to match the quotation marks to fix it. \n</code></pre> <p>A string has a set of methods that work with that type of data.</p> <pre><code>// Use a period and parentheses to call a string method.\n\nprint(\nhello,                  // Original\nhello.slice(0,2),       // Keep the first through third characters of the string.\nhello.concat('!'),      // Add an exclamation point after the string.\nhello.toUpperCase()     // Change the case to all upper. \n)\n;\n</code></pre>"},{"location":"methods/javascript/#numbers","title":"numbers","text":"<p>Use numbers to store numerical data. </p> <pre><code>// These are both numbers. \n\nvar integer = 12;\nvar decimal = 11.987654321;\n\nprint(integer, decimal);\n\n// There are not that many number methods in javascript, but you can call them.\n\nprint(decimal.toFixed(4));\n</code></pre>"},{"location":"methods/javascript/#lists","title":"lists","text":"<p>Use lists to store a set of data. </p> <pre><code>// Use square brackets to define a list.\n\nvar some_vt_towns = ['Middlebury', 'New Haven', 'Bristol'];\n\n// Use square brackets after lists to select items.\n\nprint(some_vt_towns, some_vt_towns[0]);\n\n// Call list methods with dot notation.  \n\nprint(some_vt_towns.reverse());\n</code></pre>"},{"location":"methods/javascript/#dictionaries","title":"dictionaries","text":"<p>Use dictionaries to store keys and values. </p> <pre><code>// Use curly brackets (or braces) to define dictionaries.\n\nvar midd = {\n\"name\": \"Middlebury\",  // Dictionaries are composed of key:value pairs.\n\"pop_2010\": 8496,\n\"pop_2020\": 9152\n};\n\nprint(\"Middlebury\", midd);\n\n// Use dot notation to call the value(s) of a key.\n\nprint(midd.name);\n</code></pre>"},{"location":"methods/javascript/#functions","title":"functions","text":"<p>Write functions to make chunks of code reuseable. </p> <pre><code>// A simple function the takes a string as an argument.  \n\nvar i_love_function = function(some_string) {\nreturn 'I love '.concat(some_string).concat('!');\n};\n\nprint(i_love_function('maps'));\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/map-algebra/","title":"map algebra","text":"<p>These methods use math operations to alter values in raster data objects. </p>"},{"location":"methods/map-algebra/#apply-scalar-operation","title":"apply scalar operation","text":"<p>Uniformly change the values of all data in a raster object by adding, subtracting, multiplying, or dividing the raster with a constant. </p> <p>A common example is when you need to change the units of your data. For example, to change elevation data from centimeters to meters you divide all elevation values by 100. </p> <pre><code>var output = input.divide(constant);\n</code></pre> <p>Another common example is when you want to apply vertical exaggeration to a terrain operation by multiplying the elevation values by a constant, usually called the z-factor. For example, by multiplying elevation by 2, you will exaggerate the terrain, making every location appear twice as high as it \u2018really\u2019 is. It is often helpful to exaggerate terrain when visualizing micro-topography at large scales or macro-topography at small scales.  </p> <pre><code>var output = input.multiply(constant);\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/map-raster-layers/","title":"map raster layers","text":"<p>Any geographic information system will provide methods for displaying data as a map layer.  </p> <p>To understand these patterns, it will be helpful to review some basic concepts of data visualization.  </p>"},{"location":"methods/map-raster-layers/#data-values-vs-display-values","title":"data values vs. display values","text":"<p>When you visualize data, you map data values to display values. Two things often happen by default:  </p> <ol> <li>The data type of the digital numbers defines the range of values that get mapped to the display values.</li> <li>The relationship between data values and display values is linear.  </li> </ol> <p></p> <p>The reason that the displayed values in the example above have such poor contrast is a result of the mismatch between the possible data values defined by the data type and the actual data values stored in the raster.  </p> <p>A histogram is one way to compare the possible and actual data values of a raster. </p> <p></p> <p>A common strategy to improve the contrast of an image is to stretch the display values over the range of actual data values by setting the linear map to begin and end at the minimum and maximum actual data value, respectively. This is usually called stretch enhancement.   </p> <p></p>"},{"location":"methods/map-raster-layers/#display-image-as-layer","title":"display image as layer","text":"<p>The diagram below shows a general pattern to display an image as a map layer with Earth Engine. The first two tasks \u2013 print min &amp; max value and chart histogram \u2013 are methods to identify the range of actual data values in the image and how they are distributed, respectively. The middle task \u2013 define viz dictionary \u2013 is a method for storing the min and max values for stretch enhancements. The last task \u2013 display data as map layer \u2013 draws the result on the Map.  </p> <p> <pre><code>graph LR\n\n  step01(\"Print min &amp; max value\") ;\n  step02(\"Chart histogram\") ;\n  step03(\"Define viz dictionary\")  ;\n  step04(\"display data as map layer\") ;\n\n  step01 --&gt; step03 \n  step02 --&gt; step03 \n  step03 --&gt; step04\n\n  classDef task fill:#C3D3E6,stroke-width:0px,color:#000000;\n\n  class step01 task; \n  class step02 task;\n  class step03 task;\n  class step04 task;\n</code></pre> <p></p>"},{"location":"methods/map-raster-layers/#print-min-max-value-of-image","title":"print min &amp; max value of image","text":"<p>Print the min and max data value of a raster image to use as min and max values in viz dictionary.   </p> <pre><code>var output_min_max = geo.iCart.iMinMax(input_image);\n\nprint(\"Min &amp; max value of image\", output_min_max);\n</code></pre>"},{"location":"methods/map-raster-layers/#chart-histogram-of-data-values","title":"chart histogram of data values","text":"<p>See how your data are distributed between the minimum and maximum data value by charting a histogram.</p> <pre><code>var output_histogram = geo.iCart.iHistogram(image);\n\nprint(\"Image histogram\", output_histogram);\n</code></pre>"},{"location":"methods/map-raster-layers/#define-raster-viz-dictionary","title":"define raster viz dictionary","text":"<p>For raster data, store the viz dictionary as a variable and then call this variable when you add the map layer. </p> <p>Here is a common pattern to visualize single-band grayscale images:</p> <pre><code>var single_viz = {\nmin: [],        max: [],        }\n;\n</code></pre> <p>Here is a common pattern to visualize single-band images:</p> <pre><code>var single_viz = {\nmin: [],        max: [],        palette: [],    }\n;\n</code></pre> <p>This is a common pattern to visualize multi-band images:</p> <pre><code>var multi_viz = {\nbands: [],      min:  [].      max: [],        gamma: [],      }\n;\n</code></pre>"},{"location":"methods/map-raster-layers/#add-map-layer","title":"add map layer","text":"<p><code>Map.addLayer()</code> method will display data as a map layer.    </p> <pre><code>Map.addLayer(data,viz,\"Layer Name\",show,opacity);\n</code></pre> <p>The <code>Map.addLayer()</code> method takes the following arguments: </p> ARGUMENT DESCRIPTION data The name of the variable that contains the data that you wish to display. viz The viz dictionary that defines how to visualize (display) the data. layer name A string that provides a label for the data in the list of layers. show A boolean argument to control whether or not the layer is displayed when first loaded. opacity A decimal number between 0 and 1 to adjust the opacity of the layer."},{"location":"methods/map-raster-layers/#complete-pattern","title":"complete pattern","text":"<p>Here is a complete pattern for single-band grayscale images.</p> <pre><code>// Print min and max values of image. \n\nprint(\"Min &amp; max value of image\", geo.iCart.iMinMax(image));\n\n// Chart histogram of actual data values.\n\nprint(\"Image histogram\", geo.iCart.iHistogram(image));\n\n// Define viz dictionary. \n\nvar single_viz = {\nmin: [],        max: [],        }\n;\n\n// Add map layer. \n\nMap.addLayer(image,single_viz,\"Layer Name\");\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/terrain/","title":"terrain","text":"<p>These methods derive topographic attributes of terrain from raster elevation data. </p> <p>Many terrain methods compare vertical elevation to horizontal distance. For these operations to work correctly, the vertical units (often called z-units) need to be the same as the horizontal units (xy units). Because horizontal units in Earth Engine are always meters, this means that the general pattern is to first check the z-units of your elevation data and see if you need to scale the values before you call a terrain method. </p> <p> <pre><code>graph LR\n\n  step01&gt;\"If z-units are meters\"] ;\n  step02(\"Apply a terrain method\") ;\n  step03&gt;\"If z-units are not meters\"] ;\n  step04(\"Apply scalar operation\") ;\n\n  step01 --&gt; step02\n  step03 --&gt; step04\n  step04 --&gt; step02\n\n  classDef task fill:#DDE6C3,stroke-width:0px,color:#000000;\n\n  class step01 task; \n  class step02 task;\n  class step03 task; \n  class step04 task;\n</code></pre> <p></p>"},{"location":"methods/terrain/#derive-slope","title":"derive slope","text":"<p>Derive slope of a surface in degrees from elevation in meters. </p> <p>Call the <code>ee.Terrain.slope</code> method with the elevation data (with z-units meters) as the argument.  </p> <p> <pre><code>graph LR\n  step02(\"SLOPE\") ;\n  step03[/\"OUTPUT_SLOPE\"/]  ;\n  arg01[\"elevation in meters\"] ;\n\n  step02 --&gt; step03\n  arg01 --- step02\n\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class step01 in-out; \n  class step02 op;\n  class step03 in-out;\n  class arg01 arg; </code></pre> <p></p> <pre><code>var output_slope = ee.Terrain.slope(input_elevation);\n</code></pre>"},{"location":"methods/terrain/#derive-hillshade","title":"derive hillshade","text":"<p>Shaded relief is a method to visualize a three-dimensional surface through the illusion of sunlight throwing highlights and casting shadows across a rough surface. Before computers, cartographers created shaded relief by hand (manual shaded relief) in a workflow that blended science and art. Most GIS software now provide a method to automate shaded relief, called analytic hillshading, that simplifies the shading of landscapes by modeling a fixed illumination source from an infinite distance, meaning the rays arrive in parallel from a constant angle defined by a position on the horizon (azimuth) and a position above the horizon (elevation, or sometimes called zenith).    </p> <p>In Earth Engine, the <code>ee.Terrain.hillshade()</code> method takes three arguments to output a hillshade image.  </p> <p> <pre><code>graph LR\n  step02(\"ee.Terrain.hillshade()\") ;\n  step03[/\"output_hillshade\"/]  ;\n  arg01[\"image_elevation: elevation of ground in meters\"] ;\n  arg02[\"azimuth: position of sun on horizon, in degrees\"] ;\n  arg03[\"elevation: position of sun above horizon, in degrees\"] ;\n\n  step02 --&gt; step03\n  arg01 --- step02\n  arg02 --- step02\n  arg03 --- step02\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class step01 in-out; \n  class step02 op;\n  class step03 in-out;\n  class arg01 arg;\n  class arg02 arg; \n  class arg03 arg; </code></pre> <p></p> <p>An interesting fact about the illusion of shaded relief is that it is often most effective to put the illumination source on the northwest horizon, even though the sun is rarely in this position (in the northern hemisphere). Oddly, if you place the illumination source in the southern sky, the resulting terrain will appear inverted: mountain ridges look like valleys and creeks look like ridge lines.</p> <p>more forthcoming</p> <pre><code>var image_hs = ee.Terrain.hillshade(image_elevation, 315, 45);\n</code></pre>"},{"location":"methods/terrain/#deviation-from-mean-elevation","title":"deviation from mean elevation","text":"<p>Description forthcoming </p> <pre><code>var image_dme = geo.iTerrain.devFromMeanElev(image, 10);\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"problems/01/","title":"Memory under cover on Chipman Hill","text":""},{"location":"problems/01/#goal","title":"goal","text":"<p>Your goal is to import a digital elevation model (DEM), make a Map with the five layers shown in the app below, and then use these layers to interpret the four POI.</p> <p> </p>"},{"location":"problems/01/#starter-script","title":"starter script","text":"<pre><code>// -------------------------------------------------------------\n//  Access image from this cloud address:\n//  \"projects/ee-patterns/assets/p01/chipmanHill_2023_35cm_DEMHF\"\n// -------------------------------------------------------------\n\nvar image ;\n\n\n// -------------------------------------------------------------\n//  Customize Map. \n// -------------------------------------------------------------\n\n// Set map center and zoom level.\n\n\n//  Set basemap style to hybrid.\n\n\n// -------------------------------------------------------------\n//  Display image as a map layer;\n//  Stretch layer display values over image data range.\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Multiply the elevation values by 2 (apply a scalar operation)\n//  and then derive slope of this surface.\n// -------------------------------------------------------------\n\nvar image_slope ;\n\n// -------------------------------------------------------------\n//  Display slope image as a map layer;\n//  Stretch layer display values over image data range.\n//  Display so that \"steeper is darker\".\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Multiply the elevation values by 2 (apply a scalar operation)\n//  and then calculate the hillshade of this surface. \n// -------------------------------------------------------------\n\nvar image_hs ;\n\n// -------------------------------------------------------------\n//  Using the original elevation surface (without a scalar applied),\n//  calculate the deviation from mean elevation;\n//  Use 10 as the distance argument.\n//  Try to display the layer with this palette: ['blue', 'white', 'red']\n// -------------------------------------------------------------\n\nvar image_dme ;\n\n\n// -------------------------------------------------------------\n//  PRACTICE CHECKS\n// -------------------------------------------------------------\n\n//  I. QUANTITATIVE \n\nprint(\"QUANTITATIVE CHECKS:\");\n\n//  Import check module for tutorial 1.\n//  Uncomment the line below.\n\nvar check = require(\"users/jhowarth/eePatterns:checks/p01.js\");\n\n//  Uncomment the three lines below, run script, and look at the results in Console. \n\n// check.checkPoint(\"CP1:\", image_slope);\n// check.checkPoint(\"CP2:\", image_hs);\n// check.checkPoint(\"CP3:\", image_dme);\n\n//  II. QUALITATIVE  \n\n//  Use zoom to inspect locations marked A, B, C, D.\n//  For each letter, please write down:\n\n//    1. What do you think the linear feature marked by the letter \"is\"?\n//    2. Why?\n\n//  When you have completed this practice problem, please take the short quiz on Canvas where you will report your results. \n</code></pre>"},{"location":"tutorials/01/","title":"A Sketch Map from Lidar","text":""},{"location":"tutorials/01/#goal","title":"goal","text":"<p>In this tutorial, our practical goal is to import a digital surface model (DSM) from this address:</p> <pre><code>\"projects/ee-patterns/assets/t01/Elevation_DSM0p7m2017_cm\"\n</code></pre> <p>and make a map with the layers shown below.  </p> <p> </p>"},{"location":"tutorials/01/#starter-script","title":"starter script","text":"<pre><code>// -------------------------------------------------------------\n//  Construct image data object from address.\n// -------------------------------------------------------------\n\nvar image ;\n\n// -------------------------------------------------------------\n//  Print properties of image to the Console. \n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Set map center and zoom level.\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Set basemap style.\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Display image as a map layer.\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Import geoMethods module. \n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Set viz range to data range.\n// -------------------------------------------------------------\n\nvar image_min_max ;\n\n\n\n// -------------------------------------------------------------\n//  Chart histogram of image data values.\n// -------------------------------------------------------------\n\nvar image_histogram ;\n\n\n// -------------------------------------------------------------\n//  Apply scalar operation; \n//  convert image data from centimeters to meters.\n// -------------------------------------------------------------\n\nvar image_meters ;\n\n// -------------------------------------------------------------\n//  Display new image as a layer\n//  with viz range set to data range.\n// -------------------------------------------------------------\n\n\n// -------------------------------------------------------------\n//  Derive slope of the surface image. \n// -------------------------------------------------------------\n\nvar image_slope ;\n\n// -------------------------------------------------------------\n//  Display slope image as map layer so that \"steeper is darker\".\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  TUTORIAL CHECKS\n// -------------------------------------------------------------\n\n//  I. QUANTITATIVE \n\n//  Import check module for tutorial 1.\n\nvar check = require(\"users/jhowarth/eePatterns:checks/t01.js\");\n\n//  Uncomment the four lines below, run script, and look at the results in Console. \n\n// print(\"QUANTITATIVE CHECKS:\");\n// check.checkPoint(\"CP1:\", image);\n// check.checkPoint(\"CP2:\", image_meters);\n// check.checkPoint(\"CP3:\", image_slope);\n\n//  II. QUALITATIVE  \n\n//  Use zoom to inspect locations marked A, B, C, D.\n//  For each letter, please write down:\n\n//    1. What do you think the location \"is\"?\n//    2. How does the location represent environmental change?\n\n//  We will discuss in next lecture. \n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"}]}