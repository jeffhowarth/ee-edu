{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ee pattern book","text":"<p>A collection of timeless problems of spatial analysis and image processing and how to solve them with Google Earth Engine.      </p> <p>Jeff Howarth Associate Professor of Geography  Geography Department Middlebury College Vermont, USA</p> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"geo-module/","title":"geo module","text":"<p>The geo module is a collection of methods that I am writing and packaging in a way that will allow you to use the methods without having to write them from scratch. </p> <p>I wrote these methods for two reasons:    </p> <ol> <li> <p>Each represents a recurring task of geospatial analysis that are supported by other geographic information systems (like QGIS or ArcGIS).</p> </li> <li> <p>Each requires a chain of transformations to make in Earth Engine which can be conceptually confusing and technically difficult for novices to do.    </p> </li> </ol> <p>My hope is that providing ready-made methods may help you focus on how different methods of spatial analysis and cartography work conceptually in workflows without having to get bogged down in writing complicated task chains for common tools.  </p>"},{"location":"geo-module/#import-module","title":"import module","text":"<p>To use the module, create a container and require the module. </p> <pre><code>var geo = require(\"users/jhowarth/eePatterns:modules/geo.js\");\n\nprint(\"geo methods dictionary\", geo.help);    // Prints dictionary of all tools in module.\n</code></pre> <p>The code block above will import the module and print the module\u2019s help dictionary, which lists all methods and url links to their docs. You only need to import the module once in a script the calls method in the module. I usually place the above code near the top of my script (under the header).  </p>"},{"location":"geo-module/#docs-in-eepatterns","title":"docs in eePatterns","text":"<p>A globe icon  identifies methods from module. </p> <p>In the METHODS documentation, the  symbol identifies a method that requires the geo module. To use any of these methods, you will need to include the import module in your script prior to calling the method. </p>"},{"location":"geo-module/#peak-under-hood","title":"peak under hood","text":"<p>Add module to your READER tray if you want to see the underlying code to any method.</p> <p>The module only hides the data from you if you do not want to see it. If you would like to look under the hood, I have made the code for the module public and you can add it to the READER tray of the IDE by clicking here. </p> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"intro/","title":"introduction","text":"<p>This book aims to help you create geospatial workflows with Google Earth Engine.  </p> <p>In general, these workflows grab geographic data stored in the cloud, alter it (with purpose), and then visualize the results as map layers.  </p> <p> <pre><code>graph LR\n  step01[(\"GEOGRAPHIC\\nDATA\\n\\n stored in cloud\")] ;\n  step02&gt;\"GEOSPATIAL WORKFLOW\\n\\n alter and visualize\"] ;\n\n  step01 --&gt; step02\n\n  classDef store fill:#4AA8A0,stroke-width:0px,color:#FFFFFF; \n  classDef transform fill:#4A92A8,stroke-width:0px,color:#FFFFFF;\n\n  class step01 store; \n  class step02 transform;\n\n</code></pre> <p></p> <p>To do this, we will use a web-based Integrated Development Environment (IDE) for the Earth Engine Javascript Application Programming Interface (API). That is a mouthful, but in practical terms it means that we will create workflows by writing scripts with javascript.   </p>"},{"location":"intro/#data-transformation","title":"data transformation","text":"<p>The basic element of all geospatial workflows is a three step process that Waldo Tobler called a cartographic transformation: you start with geographic data in a certain state (input), you do something to alter the data (method), and you store the result (output). Often but not always, one or more options (arguments) constrain how a method alters the input.   </p> <p> <pre><code>graph LR\n\n  input[\"INPUT\"] ;\n  method(\"METHOD\") ;\n  output[/\"OUTPUT\"/]  ;\n\n  input --&gt; method --&gt; output\n\n  arg[\"argument\"] ;\n\n  arg --o method\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class input in-out; \n  class method op;\n  class output in-out;\n  class arg arg; </code></pre> <p></p>"},{"location":"intro/#statements","title":"statements","text":"<p>With JavaScript, we transform geographic data by writing a statement. The syntax generally takes this form:</p> <pre><code>var output = input.method(argument);\n</code></pre> <p>The general pattern is that you start by defining a name for a container that you would like to make so that you can store the output. This container of data is called a variable that you create with the keyword <code>var</code>. You then say that this container will contain <code>=</code> what results from taking the input and applying a method to it <code>.</code> with one or more arguments <code>()</code>. A semicolon <code>;</code> punctuates a statement like a period (or wink ).  </p>"},{"location":"intro/#task-trees","title":"task trees","text":"<p>Workflows are a means to achieving an end. When you sit down to write a workflow, you have some goal state for the data in mind. Your problem is to figure out how to change the data from their original condition to the goal state in your head.  </p> <p>Most workflows can be decomposed into a task trees: at the top, a (big) problem  may be broken down into a sequence of smaller tasks, each of these tasks may be broken down into smaller subtasks.    </p> <pre><code>graph TD\n\n  L01(\"PROBLEM\") ;\n  L11[\"TASK 1\"] ;\n  L12[\"TASK 2\"] ;\n  L21[\"SUBTASK 1\"] ;\n  L22[\"SUBTASK 2\"] ;\n  L23[\"SUBTASK 3\"] ;\n  L24[\"SUBTASK 4\"] ;\n\n  L01 --- L11 \n  L01 --- L12\n  L11 --- L21\n  L11 --- L22\n  L12 --- L23\n  L12 --- L24\n\n  classDef L0 fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef L1 fill:#CCCCCC,stroke-width:0px,color:#000000;\n  classDef L2 fill:#000000,stroke-width:0px,color:#FFFFFF;  \n\n  class L01 L0; \n  class L11 L1;\n  class L12 L1;\n  class L21 L2;\n  class L22 L2;\n  class L23 L2;\n  class L24 L2;\n\n</code></pre> <p></p>"},{"location":"intro/#task-chains","title":"task chains","text":"<p>The lowest branches of the tree are individual transformations, the foundational elements of a workflow. Higher branches of the tree often require linking together two or more transformations in task chains, where the output of one transformation becomes the input of another. </p> <p> <pre><code>graph LR\n  step01(\"INPUT\") ;\n  step02[\"METHOD\"] ;\n  step03(\"OUTPUT\")  ;\n  step04[\"METHOD_2\"] ;\n  step05(\"OUTPUT_2\")  ;\n  arg01(\"argument\") ;\n  arg02(\"argument_2\") ;\n\n  step01 --&gt; step02 --&gt; step03 --&gt; step04 --&gt; step05\n  arg01 --- step02\n  arg02 --- step04\n\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class step01 in-out; \n  class step02 op;\n  class step03 in-out;\n  class step04 op;\n  class step05 in-out;\n  class arg01 arg;\n  class arg02 arg;\n\n</code></pre> <p></p>"},{"location":"intro/#summary","title":"summary","text":"<p>If this all sounds a bit wonky, do not worry too much. We will get to examples that illustrate all of this soon. For now, I just want you to know:  </p> <ol> <li>a workflow is a chain of input-method-output transformations </li> <li>you can think of a workflow visually (as a flow diagram) and verbally (as javascript).  </li> <li>visually, a workflow contains a vertical hierarchy of purpose (task tree) and a horizontal sequence of transformations (task chains). </li> </ol> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/customize-Map/","title":"customize Map","text":"<p>It is often helpful to customize the Map so that it centers and zooms on your area of interest and uses a base map that supports your purpose.  </p> <p>The diagram below shows a general pattern.</p> <p> <pre><code>graph LR\n\n  step01(\"Set map center and zoom\") ;\n  step02(\"Set base map style\") ;\n\n  step01 --&gt; step02\n\n  classDef task fill:#C3C8E6,stroke-width:0px,color:#000000;\n\n  class step01 task; \n  class step02 task;\n</code></pre> <p></p> <p>It is good practice to set the map center and zoom level before setting the base map so that the base map does not need to redraw.</p>"},{"location":"methods/customize-Map/#set-map-center-and-zoom","title":"set map center and zoom","text":"<p>Use a data object to center the map and to suggest an appropriate zoom level. </p> <pre><code>Map.centerObject(\nimage,              // data object\n16                  // zoom level\n);\n</code></pre>"},{"location":"methods/customize-Map/#set-basemap-style","title":"set basemap style","text":"<p>Select a basemap that provides the most helpful reference information from your data. </p> <pre><code>Map.setOptions(\"HYBRID\");\n</code></pre> <p>Choose from the following options: </p> <p><pre><code>\"ROADMAP\" </code></pre> <pre><code>\"SATELLITE\" </code></pre> <pre><code>\"HYBRID\"\n</code></pre> <pre><code>\"TERRAIN\" </code></pre></p> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/explain-code/","title":"explain code","text":"<p>Always write your code for two main audiences: </p> <ol> <li>a computer that will compile and execute your code;</li> <li>a person who will read your code and try to make sense of it. </li> </ol> <p>The second audience may be yourself in the future, when you return to a script that you wrote after some time has passed. It may be an instructor in this course who wants to help you troubleshoot something in your script that is not working. Or it may be someone you have never met who is looking to adapt and recycle parts of your script for a slightly different purpose. Whoever the reader may be, you should always aim to help people read your code by placing explanations directly in your workflow. </p> <p>The patterns below describe different ways to explain your code and make it more readable for a human audience. </p>"},{"location":"methods/explain-code/#script-header","title":"script header","text":"<p>Write a header at the top of your script.</p> <p>At a minimum, the header should identify who wrote the script, when they wrote it, and why they wrote it. This is also where many authors will define the license for the script.  </p> <p>I usually include a couple lines of repeating symbols to visually block the header and separate it from the rest of the script.  </p> <pre><code>/*    \n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    AUTHOR:   \n    DATE:     \n    TITLE:  \n\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n*/\n</code></pre>"},{"location":"methods/explain-code/#task-description","title":"task description","text":"<p>Write a line comment before each major task in your workflow.</p> <p>Describe what you are doing or why you are doing it. Use full sentences and correct punctuation (start each comment with a capital letter and end each comment with a period).  </p> <p>I usually include a line of repeating symbols above and below the task description to help visually separate the code into discrete chunks.  </p> <pre><code>// -------------------------------------------------------------\n//  To illustrate a task description.\n// -------------------------------------------------------------\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/explain-symbology/","title":"explain layer symbology","text":"<p>Methods for defining what colors in palettes mean on your map.  </p> <p>more forthcoming </p>"},{"location":"methods/explain-symbology/#define-colors-with-legend","title":"define colors with legend","text":"<p>These methods take some or all of the following arguments.</p> ARGUMENT DESCRIPTION \u201ctitle\u201d Label for the legend. Must be a string. Often a short description of image will do. viz The viz dictionary that defines how to visualize (display) the data. class_labels A list of names for each color in the palette that define the classes or categories of the data. \u201cposition-on-map\u201d Where to place the legend. Must be a string. Composed as \u201crow - column\u201d, where rows are \u201cbottom\u201d, \u201cmiddle\u201d, or \u201ctop\u201d and columns are \u201cleft\u201d, \u201ccenter\u201d, \u201cright\u201d. For example, \u201cbottom-right\u201d. There is no \u201cmiddle-center\u201d."},{"location":"methods/explain-symbology/#image-with-continuous-data","title":"image with continuous data","text":"<p>If the image contains continuous or cyclical data, place a snapshot of the color gradient on the Map with labels that identify the minimum, maximum, and midpoint data value mapped to the gradient. </p> <pre><code>// Make legend from image with continuous data. \n\nvar legend_continuous = geo.iCart.legendContinuous(\n\"title\", viz, \"position-on-map\"\n)\n;\n\n// Add legend to Map.  \n\nMap.add(legend_continuous);\n</code></pre>"},{"location":"methods/explain-symbology/#from-image-with-nominal-data","title":"from image with nominal data","text":"<p>If the image contains nominal (discrete) data, place a symbol dictionary that defines each swatch of the palette with a label, or name for the class.     </p> <pre><code>// Make legend from image with nominal data.\n\nvar legend_nominal = geo.iCart.legendNominal(\n\"title\", viz, class_labels, \"position-on-map\"\n)\n;\n\n// Add legend to Map.  \n\nMap.add(legend_remapped);\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/gather-raster-data/","title":"gather raster data","text":"<p>One of the first things you will usually do with Earth Engine is gather some data from the cloud. Before we get too deep into this, we should review the basic templates for storing geographic data (geographic data models) and how they are implemented in Earth Engine.     </p>"},{"location":"methods/gather-raster-data/#raster-data-model","title":"raster data model","text":"<p>A raster stores geographic data with a grid of pixels. Each pixel, or cell in the grid, stores a value as a digital number. The data type defines the length of binary numbers used to store the digital number. In the diagram below, the values shown on the left can be stored as a 8 bit unsigned integer, or byte, data type shown on the right. </p> <p></p>"},{"location":"methods/gather-raster-data/#image-data-object","title":"image data object","text":"<p>In Earth Engine, the raster model underlies the image data object, where an image is composed of one or more bands and each band is a raster.  </p> <p></p>"},{"location":"methods/gather-raster-data/#accessing-images-from-cloud","title":"accessing images from cloud","text":"<p>The diagram below shows a typical pattern for accessing cloud data.</p> <p> <pre><code>graph LR\n\n  step01(\"Construct from address\") ;\n  step02(\"Inspect data object\") ;\n\n  step01 --&gt; step02\n\n  classDef task fill:#C9C3E6,stroke-width:0px,color:#000000;\n\n  class step01 task; \n  class step02 task;\n</code></pre> <p></p> <p>The pattern is to first construct the object and then immediately inspect the properties of the object.  </p>"},{"location":"methods/gather-raster-data/#construct-image-from-address","title":"construct image from address","text":"<p>Use the <code>ee.Image()</code> method to construct an image from the cloud. This method takes the address for the data asset as an argument.   </p> <p> <pre><code>graph LR\n  step02(\"ee.Image()\") ;\n  step03[/\"image\"/]  ;\n  arg01[\"'address/of/cloud/data'\"] ;\n\n  step02 --&gt; step03\n  arg01 --o step02\n\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class step01 in-out; \n  class step02 op;\n  class step03 in-out;\n  class arg01 arg; </code></pre> <p></p> <p>To adapt the snippet below, you will just need to replace <code>'address/of/cloud/data'</code> with the data address. The address must be a string.  </p> <pre><code>var image = ee.Image('address/of/cloud/data');\n</code></pre>"},{"location":"methods/gather-raster-data/#inspect-data-properties","title":"inspect data properties","text":"<p>After constructing or altering a data object, I usually want to quickly familiarize myself the properties of the data. To do this, use the <code>print()</code> method to print the properties of the data object to the Console.  </p> <pre><code>print(\n\"A helpful label\",\nimage\n)\n;\n</code></pre> <p>To adapt the snippet below, replace <code>\"A helpful label\"</code> with a label that describes the image you are working with. This label must be a string. As necessary, replace <code>image</code> in the following line with the name of the variable that contains the image data.  </p>"},{"location":"methods/gather-raster-data/#full-pattern","title":"full pattern","text":"<p>Here are the two parts of the pattern together.</p> <pre><code>var image = ee.Image('address/of/cloud/data');\n\nprint(\n\"A helpful label\",\nimage\n)\n;\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/javascript/","title":"JavaScript","text":"<p>Here are some basic patterns for writing in JavaScript.</p>"},{"location":"methods/javascript/#comments","title":"comments","text":"<p>Use comments to explain your code.</p> <pre><code>// Line comments start with two forward slashes. Like this line. \n\n/* Multi-line comments start with a forward slash and a star,\nand end with a star and a forward slash. */ </code></pre>"},{"location":"methods/javascript/#variables","title":"variables","text":"<p>Use variables to contain (hold, store) data. </p> <pre><code>// Write a statement using the keyword var.\n\nvar hello = 'Hello world';    // Statements should end in a semi-colon, or else the Code Editor complains.\n\nvar test = \"I feel incomplete...\"\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// !! Variable names cannot contain spaces or - dashes - !!\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n// Use underscores to separate words in variable names.\n\nvar this_is_called_snake_case = 'Hello, snake!';\n\n// Or use capitalizations to separate words:\n\nvar thisIsCalledCamelCase = 'Hello, camel!';\n</code></pre>"},{"location":"methods/javascript/#print-to-console","title":"print to console","text":"<p>Use print function to print contents of variables and objects to console. </p> <pre><code>// Use parenthesis to pass arguments to print function.  \n\nprint(hello);\n\n// Use commas to pass multiple arguments. \n\nprint('Print test', hello);\n</code></pre>"},{"location":"methods/javascript/#strings","title":"strings","text":"<p>Use strings to store text (character strings). </p> <pre><code>// Use single quotes to define string.\n\nvar hello = \"Hello world!\"  // This is a string. \n\n// You can also use double quotes to enclose string.\n\nvar obi_one = \"Hello there\";\n\n// Just do not mix them.\n\nvar cranky = \"Hello Newman';  // This will throw an error. You will need to match the quotation marks to fix it. \n</code></pre> <p>A string has a set of methods that work with that type of data.</p> <pre><code>// Use a period and parentheses to call a string method.\n\nprint(\nhello,                  // Original\nhello.slice(0,2),       // Keep the first through third characters of the string.\nhello.concat('!'),      // Add an exclamation point after the string.\nhello.toUpperCase()     // Change the case to all upper. \n)\n;\n</code></pre>"},{"location":"methods/javascript/#numbers","title":"numbers","text":"<p>Use numbers to store numerical data. </p> <pre><code>// These are both numbers. \n\nvar integer = 12;\nvar decimal = 11.987654321;\n\nprint(integer, decimal);\n\n// There are not that many number methods in javascript, but you can call them.\n\nprint(decimal.toFixed(4));\n</code></pre>"},{"location":"methods/javascript/#lists","title":"lists","text":"<p>Use lists to store a set of data. </p> <pre><code>// Use square brackets to define a list.\n\nvar some_vt_towns = ['Middlebury', 'New Haven', 'Bristol'];\n\n// Use square brackets after lists to select items.\n\nprint(some_vt_towns, some_vt_towns[0]);\n\n// Call list methods with dot notation.  \n\nprint(some_vt_towns.reverse());\n</code></pre>"},{"location":"methods/javascript/#dictionaries","title":"dictionaries","text":"<p>Use dictionaries to store keys and values. </p> <pre><code>// Use curly brackets (or braces) to define dictionaries.\n\nvar midd = {\n\"name\": \"Middlebury\",  // Dictionaries are composed of key:value pairs.\n\"pop_2010\": 8496,\n\"pop_2020\": 9152\n};\n\nprint(\"Middlebury\", midd);\n\n// Use dot notation to call the value(s) of a key.\n\nprint(midd.name);\n</code></pre>"},{"location":"methods/javascript/#functions","title":"functions","text":"<p>Write functions to make chunks of code reuseable. </p> <pre><code>// A simple function the takes a string as an argument.  \n\nvar i_love_function = function(some_string) {\nreturn 'I love '.concat(some_string).concat('!');\n};\n\nprint(i_love_function('maps'));\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/local-operations/","title":"local operations","text":"<p>These methods compare values at corresponding pixels in two or more rasters. </p> <p>more forthcoming </p>"},{"location":"methods/local-operations/#mask-pixels","title":"mask pixels","text":"<p>I think of masks like masking tape when you are painting. Any pixel with the value 0 in the mask acts like tape and prevents numbers in the output raster from being painted at that location.  </p> <p></p> <p> <pre><code>graph LR\n  input[image]\n  method(\".updateMask()\") ;\n  output[/\"image_with_mask\"/]  ;\n  arg01[\"masking_image\"] ;\n\n  input --&gt; method\n  method --&gt; output\n  arg01 --o method\n\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class input in-out; \n  class method op;\n  class output in-out;\n  class arg01 arg; </code></pre> <p></p> <pre><code>var image_with_mask = image.updateMask(masking_image);\n</code></pre>"},{"location":"methods/local-operations/#self-mask-pixels","title":"self mask pixels","text":"<p>If you want to ignore pixels that store the value 0 in an image, you can self-mask.  </p> <p></p> <p> <pre><code>graph LR\n  input[image]\n  method(\".selfMask()\") ;\n  output[/\"image_with_mask\"/]  ;\n\n  input --&gt; method\n  method --&gt; output\n\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class input in-out; \n  class method op;\n  class output in-out;</code></pre> <p></p> <pre><code>var image_with_mask = image.selfMask();\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/map-raster-layers/","title":"map raster layers","text":"<p>Any geographic information system will provide methods for displaying data as a map layer.  </p> <p>To understand these patterns, it will be helpful to review some basic concepts of data visualization.  </p>"},{"location":"methods/map-raster-layers/#data-values-vs-display-values","title":"data values vs. display values","text":"<p>When you visualize data, you map data values to display values. Two things often happen by default:  </p> <ol> <li>The data type of the digital numbers defines the range of values that get mapped to the display values.</li> <li>The relationship between data values and display values is linear.  </li> </ol> <p></p> <p>The reason that the displayed values in the example above have such poor contrast is a result of the mismatch between the possible data values defined by the data type and the actual data values stored in the raster.  </p> <p>A histogram is one way to compare the possible and actual data values of a raster. </p> <p></p> <p>A common strategy to improve the contrast of an image is to stretch the display values over the range of actual data values by setting the linear map to begin and end at the minimum and maximum actual data value, respectively. This is usually called stretch enhancement.   </p> <p></p>"},{"location":"methods/map-raster-layers/#display-image-as-layer","title":"display image as layer","text":"<p>The diagram below shows a general pattern to display an image as a map layer with Earth Engine. The first two tasks \u2013 print min &amp; max value and chart histogram \u2013 are methods to identify the range of actual data values in the image and how they are distributed, respectively. The middle task \u2013 define viz dictionary \u2013 is a method for storing the min and max values for stretch enhancements. The last task \u2013 display data as map layer \u2013 draws the result on the Map.  </p> <p> <pre><code>graph LR\n\n  step01(\"Print min &amp; max value\") ;\n  step02(\"Chart histogram\") ;\n  step03(\"Define viz dictionary\")  ;\n  step04(\"display data as map layer\") ;\n\n  step01 --&gt; step03 \n  step02 --&gt; step03 \n  step03 --&gt; step04\n\n  classDef task fill:#C3D3E6,stroke-width:0px,color:#000000;\n\n  class step01 task; \n  class step02 task;\n  class step03 task;\n  class step04 task;\n</code></pre> <p></p>"},{"location":"methods/map-raster-layers/#print-min-max-value-of-image","title":"print min &amp; max value of image","text":"<p>Print the min and max data value of a raster image to use as min and max values in viz dictionary.   </p> <pre><code>var output_min_max = geo.iCart.iMinMax(image, scale, extent);\n\nprint(\"Min &amp; max value of image\", output_min_max);\n</code></pre> ARGUMENT DESCRIPTION image The name of the variable that contains the image data to process. scale The scale of analysis. If possible, use the scale (resolution) of the input image. If this runs really slow (or times out), then increase the scale of analysis by a factor of 2 or more. extent Usually the area of interest or the geographic footprint of the image."},{"location":"methods/map-raster-layers/#chart-histogram-of-data-values","title":"chart histogram of data values","text":"<p>See how your data are distributed between the minimum and maximum data value by charting a histogram.</p> <pre><code>var output_histogram = geo.iCart.iHistogram(image, scale, extent);\n\nprint(\"Image histogram\", output_histogram);\n</code></pre> ARGUMENT DESCRIPTION input_image The name of the variable that contains the image data to process. scale The scale of analysis. If possible, use the scale (resolution) of the input image. If this runs really slow (or times out), then increase the scale of analysis by a factor of 2 or more. extent Usually the area of interest or the geographic footprint of the image."},{"location":"methods/map-raster-layers/#define-raster-viz-dictionary","title":"define raster viz dictionary","text":"<p>For raster data, store the viz dictionary as a variable and then call this variable when you add the map layer. </p> <p>Here is a common pattern to visualize single-band grayscale images:</p> <pre><code>var single_viz = {\nmin: [],        max: [],        }\n;\n</code></pre> <p>Here is a common pattern to visualize single-band pseudo-color images:</p> <pre><code>var single_viz = {\nmin: [],        max: [],        palette: [],    }\n;\n</code></pre> <p>This is a common pattern to visualize multi-band images:</p> <pre><code>var multi_viz = {\nbands: [],      min:  [].      max: [],        gamma: [],      }\n;\n</code></pre>"},{"location":"methods/map-raster-layers/#add-map-layer","title":"add map layer","text":"<p><code>Map.addLayer()</code> method will display data as a map layer.    </p> <pre><code>Map.addLayer(data,viz,\"Layer Name\",show,opacity);\n</code></pre> <p>The <code>Map.addLayer()</code> method takes the following arguments: </p> ARGUMENT DESCRIPTION data The name of the variable that contains the data that you wish to display. viz The viz dictionary that defines how to visualize (display) the data. layer name A string that provides a label for the data in the list of layers. show A boolean argument to control whether or not the layer is displayed when first loaded. opacity A decimal number between 0 and 1 to adjust the opacity of the layer."},{"location":"methods/map-raster-layers/#complete-pattern","title":"complete pattern","text":"<p>Here is a complete pattern for single-band grayscale images.</p> <pre><code>// Print min and max values of image. \n\nprint(\"Min &amp; max value of image\", geo.iCart.iMinMax(image, scale, extent));\n\n// Chart histogram of actual data values.\n\nprint(\"Image histogram\", geo.iCart.iHistogram(image, scale, extent));\n\n// Define viz dictionary. \n\nvar single_viz = {\nmin: [],        max: [],        }\n;\n\n// Add map layer. \n\nMap.addLayer(image,single_viz,\"Layer Name\");\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/reclassify/","title":"reclassify images","text":"<p>These methods purposefully reclassify the values in an image. </p> <p>more forthcoming </p>"},{"location":"methods/reclassify/#make-a-boolean-truefalse-raster","title":"Make a boolean (true/false) raster","text":"<p> <pre><code>graph LR\n  input[image]\n  method(\".gt()\") ;\n  output[/\"image_boolean\"/]  ;\n  arg1[\"20\"]  ;\n\n  input --&gt; method\n  method --&gt; output\n  arg1 --o method\n\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class input in-out; \n  class method op;\n  class output in-out;\n  class arg1 arg;</code></pre> <p></p> <pre><code>var image_boolean = image.gt(20);  </code></pre> <p>The table below lists some of the common methods to ask true or false questions about a raster. Each takes a number as an argument. </p> <p> METHOD DESCRIPTION <code>.eq()</code>, <code>.neq()</code> Equal to, not equal to <code>.gt()</code> <code>.gte()</code> Greater than, greater than or equal to <code>.lt()</code> <code>.lte()</code> Less than, less than or equal to <p></p>"},{"location":"methods/reclassify/#reclassify-by-equal-intervals","title":"Reclassify by equal intervals","text":"<p> <pre><code>graph LR\n  method(\"geo.iReclass.equalInterval()\") ;\n  output[/\"image_reclassified\"/]  ;\n  arg1[\"image\"]  ;\n  arg2[\"interval\"]  ;\n\n  method --&gt; output\n  arg1 --o method\n  arg2 --o method\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class method op;\n  class output in-out;\n  class arg1 arg;\n  class arg2 arg;</code></pre> <p></p> <pre><code>var image_reclassified = geo.iReclass.equalInterval(image, interval);\n</code></pre>"},{"location":"methods/reclassify/#remap-old-values-to-new-values","title":"Remap old values to new values","text":"<p> <pre><code>graph LR\n  input[\"image\"] ;\n  method(\".remap()\") ;\n  output[/\"image_remapped\"/]  ;\n  arg1[\"[original values]\"]  ;\n  arg2[\"[new values]\"]  ;\n\n  input --&gt; method  \n  method --&gt; output\n  arg1 --o method\n  arg2 --o method\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n  class input in-out;\n  class method op;\n  class output in-out;\n  class arg1 arg;\n  class arg2 arg;</code></pre> <p></p> <pre><code>var image_remapped = image.remap(\n[1,2,3,4,5,6,7,8,9,10],            // Original values\n[1,1,2,2,3,3,4,4,5, 5]             // New values\n)\n;\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/scalar-operations/","title":"scalar operations","text":"<p>Uniformly change the values of all data in a raster object by adding, subtracting, multiplying, or dividing the raster with a constant.   </p>"},{"location":"methods/scalar-operations/#change-value-units","title":"change value units","text":"<p>A common example is when you need to change the units of your data. For example, to change elevation data from centimeters to meters you divide all elevation values by 100. </p> <pre><code>var output = input.divide(constant);\n</code></pre>"},{"location":"methods/scalar-operations/#vertical-exaggeration","title":"vertical exaggeration","text":"<p>Another common example is when you want to apply vertical exaggeration to a terrain operation by multiplying the elevation values by a constant, usually called the z-factor. For example, by multiplying elevation by 2, you will exaggerate the terrain, making every location appear twice as high as it \u2018really\u2019 is. It is often helpful to exaggerate terrain when visualizing micro-topography at large scales or macro-topography at small scales.  </p> <pre><code>var output = input.multiply(constant);\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"methods/terrain/","title":"terrain","text":"<p>These methods derive topographic attributes of terrain from raster elevation data. Before we get too deep into these methods, it is helpful to understand some general concepts about terrain analysis with raster data models.  </p>"},{"location":"methods/terrain/#neighborhood-operations","title":"neighborhood operations","text":"<p>Most terrain operations characterize attributes of a surface with a moving window, a zone of analysis in the neighborhood of a focal cell that moves systematically across each pixel of a raster.     </p> <p></p> <p>The result of each neighborhood calculation is stored in the output raster pixel that corresponds with the location of the focal pixel in the input raster. The shape and size of the moving window is defined by a kernel.  The example below uses a square, 3 x 3 pixel kernel to compute the average neighborhood value for a focal pixel.  </p> <p></p>"},{"location":"methods/terrain/#change-in-elevation","title":"change in elevation","text":""},{"location":"methods/terrain/#concepts","title":"concepts","text":"<p>Slope describes how the vertical dimension of space changes with respect to the  horizontal dimension. Many of us first learn about slope as \u201crise over run\u201d which can be expressed as a percentage. Most GIS will compute slope as a percentage or in degrees. Earth Engine calculates slope in degrees and then, if you would like to find the percent slope for your application, it leaves it to you to convert from degrees to percentage with scalar operations.  </p> <p></p> <p>A raster model will define \u201crun\u201d based on distance between the centers of cells. As a result, the distance between two adjacent cells that share a side will be the same as the length of a pixel side, or the scale of the raster.   </p> <p></p> <p>In raster analysis, a common slope computation employs a neighborhood operation with a kernel that resembles a \u201cplus\u201d sign. The crosspiece of the plus computes the difference in z-values (elevation) for the x dimension, while the post of the plus computes the difference in z-values for the y dimension. The change in elevation with respect to change in distance can be found by dividing by the distance across the crosspiece or post (which will both be double the cell size). The degree of slope is then found through some trigonometry.</p> <p></p> <p>Because the slope calculation directly compares changes in elevation with changes in distance, the units of the z-values must be the same as the units of the xy values. In Earth Engine, the xy units will generally be meters. Therefore, accurate slope computations require elevation data in meters.   </p>"},{"location":"methods/terrain/#decision-flow","title":"decision flow","text":"<p>The workflow for slope analysis will often depend on the data you are using and your purpose. I tend to think through some version of the flowchart depicted below. The </p> <p> <pre><code>graph TD\n\n  q1&gt;\"Do z-units = xy units?\"] ;\n  q2&gt;\"Is your purpose to visualize slope shading?\"] ;\n  q3&gt;\"Does your application require slope in percent?\"] ;  \n  step01(\"Change units \\n\\n APPLY SCALAR\") ;\n  step02(\"Consider changing z-factor \\n\\n APPLY SCALAR\") ;\n  step03(\"Derive slope\") ;\n  step04(\"Convert slope units\") ;\n  step05(&amp;#128526);\n\n  q1-- NO --&gt;step01 --&gt; q2\n  q1-- YES --&gt;q2\n  q2-- YES --&gt;step02\n  q2-- NO --&gt;step03\n  step02 --&gt; step03\n  step03 --&gt; q3\n  q3-- YES --&gt; step04  \n  q3 -- NO --&gt; step05\n  step04 --&gt; step05\n\n\n\n  classDef task fill:#DDE6C3,stroke-width:0px,color:#000000;\n  classDef check fill:#C3D1E6, stroke-width:0px,color:#000000;  \n  classDef done fill:#FFFFFF, stroke-width:0px,color:#000000;  \n\n\n  class q1 check; \n  class q2 check; \n  class q3 check; \n  class step01 task;\n  class step02 task;\n  class step03 task;\n  class step04 task;\n  class step05 done; \n</code></pre> <p></p>"},{"location":"methods/terrain/#slope-method","title":"slope method","text":"<p>Derive slope of a surface in degrees from elevation in meters. </p> <p>Call the <code>ee.Terrain.slope</code> method with the elevation data (with z-units meters) as the argument.  </p> <p> <pre><code>graph LR\n  step02(\"ee.Terrain.slope()\") ;\n  step03[/\"image_slope\"/]  ;\n  arg01[\"image_elevation_meters\"] ;\n\n  step02 --&gt; step03\n  arg01 --o step02\n\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class step01 in-out; \n  class step02 op;\n  class step03 in-out;\n  class arg01 arg; </code></pre> <p></p> <pre><code>var image_slope = ee.Terrain.slope(image_elevation_meters);\n</code></pre>"},{"location":"methods/terrain/#direction-of-change","title":"direction of change","text":""},{"location":"methods/terrain/#concepts_1","title":"concepts","text":"<p>Closely related to slope, aspect reports the direction of change, or the steepest downhill direction of a pixel. </p> <p>Like slope, aspect is derived with a kernel that computes change in elevation in both x- and y- dimensions, but rather than reporting the steepness of the slope, aspect reports the direction, generally expressed as an azimuthal angle from North 0.  </p> <p> </p>"},{"location":"methods/terrain/#aspect-method","title":"aspect method","text":"<p>In Earth Engine, the aspect method closely resembles the pattern for slope. </p> <p> <pre><code>graph LR\n  step02(\"ee.Terrain.aspect()\") ;\n  step03[/\"image_aspect\"/]  ;\n  arg01[\"image_elevation_meters\"] ;\n\n  step02 --&gt; step03\n  arg01 --o step02\n\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class step01 in-out; \n  class step02 op;\n  class step03 in-out;\n  class arg01 arg; </code></pre> <p></p> <pre><code>var image_aspect = ee.Terrain.aspect(image_elevation_meters);\n</code></pre> <p>Because the method directly compares changes in z-values to changes in x- and y- values, the units for elevation must match the units for x- and y- dimensions. Practically, this means the elevation units must be meters.  </p> <p>The output aspect image reports the direction of slope in degrees. Completely flat pixels (with no slope direction) receive the value 0. It is often good practice to mask these pixels so as not to confuse them with north-facing locations.  </p>"},{"location":"methods/terrain/#analytic-hillshading","title":"analytic hillshading","text":""},{"location":"methods/terrain/#concepts_2","title":"concepts","text":"<p>Shaded relief is a method to visualize a three-dimensional surface by creating the illusion of highlights and shadows thrown by sunlight on a terrain. Before computers, cartographers created shaded relief by hand (manual shaded relief) in a workflow that blended science and art. Most GIS software now provide a method to automate shaded relief, called analytic hillshading, that simplifies the shading illusion. </p> <p>The method assumes that the illumination source (sun) is an infinite distance from Earth. As a result, the illumination rays travel and reach the Earth\u2019s surface in parallel.  </p> <p></p> <p>The angle of the illumination rays depends on the sun\u2019s position, which is determined by two coordinates. The solar azimuth angle defines the sun\u2019s position on the horizon in degrees from North. It is often most effective to put the illumination source above the northwest horizon, even though in the northern hemisphere it would be unusual to find the sun in this part of the sky. An interesting fact about the illusion of shaded relief is that placing the illumination source in the southern sky will make the landscape appear inverted: mountain ridges look like valleys and creeks look like ridge lines. Because of this, many analytic hillshade tools in GIS will use 315 as the starting solar azimuth angle. You can then adjust this \u00b1 30 degrees depending on the orientation of ridges and valleys in the area of interest, while taking care not to invert the landscape by pushing the sun too far.  </p> <p>The second solar coordinate the defines the sun\u2019s position above the horizon, or how high the sun hangs in the sky. Many GIS call this the zenith angle, but in Earth Engine it is called elevation. If the sun is directly overhead, the zenith angle is 90 and the sun approaches 0 as it nears the horizon. By default, many GIS go with the Goldilocks solution and set the zenith angle at 45. It is often good to start here and then adjust based on your terrain. Lowering the zenith angle can be helpful on flat terrain, while raising the angle can be helpful in more rugged landscapes.       </p> <p></p> <p>The brightness of the reflected ray is determined by the local incidence angle from the surface normal (perpendicular to the surface). When the incidence angle is near 0, the rays directly strike the surface and reflect at their brightest power. Because most GIS will store the output of the analytic hillshade method as a byte data type (0-255), the brightest pixels will have the data value 255. In a grayscale palette, this value will be displayed white. As the incidence angle increases, the rays strike the surface obliquely, the brightness values decrease, and the display values change from white to gray. As the angle exceeds 90, the brightness values change from gray to black.</p> <p> </p>"},{"location":"methods/terrain/#hillshade-operation","title":"hillshade operation","text":"<p>In Earth Engine, the <code>ee.Terrain.hillshade()</code> method takes three arguments to output a hillshade image.  </p> <p> <pre><code>graph LR\n  step02(\"ee.Terrain.hillshade()\") ; \n  step03[/\"image_hs\"/]  ;\n  arg01[\"image_elevation_meters\"] ;\n  arg02[\"azimuth angle\"] ;\n  arg03[\"zenith angle\"] ;\n\n  step02 --&gt; step03\n  arg01 --o step02\n  arg02 --o step02\n  arg03 --o step02\n\n  classDef in-out fill:#FFFFFF,stroke-width:1px,stroke: #000000, color:#000000; \n  classDef op fill:#000000,stroke-width:0px,color:#FFFFFF;\n  classDef arg fill:#CCCCCC,stroke-width:0px,color:#000000;\n\n\n  class step01 in-out; \n  class step02 op;\n  class step03 in-out;\n  class arg01 arg;\n  class arg02 arg; \n  class arg03 arg; </code></pre> <p></p> <pre><code>var image_hs = ee.Terrain.hillshade(image_elevation_meters, azimuth, zenith);\n</code></pre>"},{"location":"methods/terrain/#deviation-from-mean-elevation","title":"deviation from mean elevation","text":"<p>Description forthcoming </p> <pre><code>var image_dme = geo.iTerrain.devFromMeanElev(image, 10);\n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"practice/01/","title":"Memory under cover on Chipman Hill","text":""},{"location":"practice/01/#goal","title":"goal","text":"<p>Your goal is to import a digital elevation model (DEM), make a Map with the five layers shown in the app below, and then use these layers to interpret the four POI.</p> <p> </p> <p>open app in new tab</p>"},{"location":"practice/01/#starter-script","title":"starter script","text":"<pre><code>// -------------------------------------------------------------\n//  Access image from this cloud address:\n//  \"projects/ee-patterns/assets/p01/chipmanHill_2023_35cm_DEMHF\"\n// -------------------------------------------------------------\n\nvar image ;\n\n\n// -------------------------------------------------------------\n//  Customize Map. \n// -------------------------------------------------------------\n\n// Set map center and zoom level.\n\n\n//  Set basemap style to hybrid.\n\n\n// -------------------------------------------------------------\n//  Display image as a map layer;\n//  Stretch layer display values over image data range.\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Multiply the elevation values by 2 (apply a scalar operation)\n//  and then derive slope of this surface.\n// -------------------------------------------------------------\n\nvar image_slope ;\n\n// -------------------------------------------------------------\n//  Display slope image as a map layer;\n//  Stretch layer display values over image data range.\n//  Display so that \"steeper is darker\".\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Multiply the elevation values by 2 (apply a scalar operation)\n//  and then calculate the hillshade of this surface. \n// -------------------------------------------------------------\n\nvar image_hs ;\n\n// -------------------------------------------------------------\n//  Using the original elevation surface (without a scalar applied),\n//  calculate the deviation from mean elevation;\n//  Use 10 as the distance argument.\n//  Try to display the layer with this palette: ['blue', 'white', 'red']\n// -------------------------------------------------------------\n\nvar image_dme ;\n\n\n// -------------------------------------------------------------\n//  PRACTICE CHECKS\n// -------------------------------------------------------------\n\n//  I. QUANTITATIVE \n\nprint(\"QUANTITATIVE CHECKS:\");\n\n//  Import check module for tutorial 1.\n//  Uncomment the line below.\n\nvar check = require(\"users/jhowarth/eePatterns:checks/p01.js\");\n\n//  Uncomment the three lines below, run script, and look at the results in Console. \n\n// check.checkPoint(\"CP1:\", image_slope);\n// check.checkPoint(\"CP2:\", image_hs);\n// check.checkPoint(\"CP3:\", image_dme);\n\n//  II. QUALITATIVE  \n\n//  Use zoom to inspect locations marked A, B, C, D.\n//  For each letter, please write down:\n\n//    1. What do you think the linear feature marked by the letter \"is\"?\n//    2. Why?\n\n//  When you have completed this practice problem, please take the short quiz on Canvas where you will report your results. \n</code></pre>"},{"location":"practice/02/","title":"Ice age bathtub","text":""},{"location":"practice/02/#goal","title":"goal","text":"<p>Your goal is to import a digital elevation model (DEM), make a Map with the four layers shown in the app below.</p> <p> </p> <p>open app in new tab</p>"},{"location":"practice/02/#starter-script","title":"starter script","text":"<pre><code>var geo = require(\"users/jhowarth/eePatterns:modules/geo.js\");\n\nprint(\"geo methods dictionary\", geo.help);    // Prints dictionary of all tools in module.\nprint(\"geo palettes\", geo.iPalettes);         // Prints dictionary of all palettes in module.  \n\n// -------------------------------------------------------------------------------\n//  Gather image from \"projects/ee-patterns/assets/p02/NOAA-CoNED-SOCAL\".\n//  Print a histogram - do you see land vs ocean floor in the histogram?\n// -------------------------------------------------------------------------------\n\n// var bathy = ee.Image(\"projects/sat-io/open-datasets/gebco/gebco_grid/gebco_2023_n900_s00_w-1800_e-900\");\n\nvar image = ee.Image(\"projects/ee-patterns/assets/p02/NOAA-CoNED-SOCAL\");\n\nprint(\"Image\", image);\n\n\n// -------------------------------------------------------------------------------\n//  Area of interest for practice problem.\n// -------------------------------------------------------------------------------\n\nvar aoi = image.geometry();\n\n\n// Center map on aoi at zoom level 9 and set base layer to hybrid.\n\n\n\n\n// -------------------------------------------------------------------------------\n//  Apply a vertical exageration (z-factor) of 2 to elevation data for hillshade. \n//  Make a hillshade from this image and display the hillshade image as layer on Map.\n// -------------------------------------------------------------------------------\n\nvar image_ve ;\n\nvar image_hs ;\n\n\n// -------------------------------------------------------------------------------\n//  Separate the original elevation image (without vertical exageration) into two different images:\n\n//  (1) land elevations\n//  (2) ocean floor elevations (bathymetry)\n\n//  Each image should only store land or bathymetry elevation values, respectively.\n//  All other values should be masked.\n// -------------------------------------------------------------------------------\n\nvar image_land ;\n\nvar image_bathy ;\n\n// -------------------------------------------------------------------------------\n//  Reclassify the bathymetry image at 100 meter intervals. \n//  Display the reclassified image as layer on Map with 0.5 opacity.\n//  To improve contrast, set max of viz dictionary such that all locations less than -2000 m (or class 20) are the darkest blue in palette.\n//  Use this palette: geo.iPalettes.iBathy.eleven\n// -------------------------------------------------------------------------------\n\n\n\nvar image_bathy_reclass ;\n\n\n\n// -------------------------------------------------------------------------------\n//  Define the Pleistocene shoreline as 130 meters lower than today's shoreline.\n//  Make a boolean image that shows all land above ocean in Pleistocene.\n//  Display boolean image as layer on Map with all non-land masked.\n//  Set opacity of layer at 0.5.\n// -------------------------------------------------------------------------------\n\nvar image_pleistocene ;\n\nvar image_pleistocene_boolean ;\n\n\n// -------------------------------------------------------------------------------\n//  Reclassify the land image at equal 100 meter intervals. \n//  Display the reclassified image as layer on Map with 0.5 opacity.\n//  Use this palette: geo.iPalettes.iHypso.bartholomew\n//  Set opacity of layer at 0.5.\n// -------------------------------------------------------------------------------\n\nvar image_land_reclass ;\n\n\n\n\n// -------------------------------------------------------------\n//  PRACTICE CHECKS\n// -------------------------------------------------------------\n\n//  I. QUANTITATIVE \n\nprint(\"QUANTITATIVE CHECKS:\");\n\n//  Import check module for tutorial 1.\n\nvar check = require(\"users/jhowarth/eePatterns:checks/p02.js\");\n\n//  Uncomment the five lines below, run script, and look at the results in Console. \n\n// check.checkPoint(\"CP1:\", image_hs);\n// check.checkPoint(\"CP2:\", image_land);\n// check.checkPoint(\"CP3:\", image_bathy);\n// check.checkPoint(\"CP4:\", image_pleistocene);\n// check.checkPoint(\"CP5:\", image_bathy_reclass);\n</code></pre>"},{"location":"tutorials/01/","title":"A Sketch Map from Lidar","text":""},{"location":"tutorials/01/#goal","title":"goal","text":"<p>In this tutorial, our practical goal is to import a digital surface model (DSM) from this address:</p> <pre><code>\"projects/ee-patterns/assets/t01/Elevation_DSM0p7m2017_cm\"\n</code></pre> <p>and make a map with the layers shown below.  </p> <p> </p> <p>open app in new tab</p>"},{"location":"tutorials/01/#starter-script","title":"starter script","text":"<pre><code>// -------------------------------------------------------------\n//  Construct image data object from address.\n// -------------------------------------------------------------\n\nvar image ;\n\n// -------------------------------------------------------------\n//  Print properties of image to the Console. \n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Set map center and zoom level.\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Set basemap style.\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Display image as a map layer.\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Import geoMethods module. \n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  Set viz range to data range.\n// -------------------------------------------------------------\n\nvar image_min_max ;\n\n\n\n// -------------------------------------------------------------\n//  Chart histogram of image data values.\n// -------------------------------------------------------------\n\nvar image_histogram ;\n\n\n// -------------------------------------------------------------\n//  Apply scalar operation; \n//  convert image data from centimeters to meters.\n// -------------------------------------------------------------\n\nvar image_meters ;\n\n// -------------------------------------------------------------\n//  Display new image as a layer\n//  with viz range set to data range.\n// -------------------------------------------------------------\n\n\n// -------------------------------------------------------------\n//  Derive slope of the surface image. \n// -------------------------------------------------------------\n\nvar image_slope ;\n\n// -------------------------------------------------------------\n//  Display slope image as map layer so that \"steeper is darker\".\n// -------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------\n//  TUTORIAL CHECKS\n// -------------------------------------------------------------\n\n//  I. QUANTITATIVE \n\n//  Import check module for tutorial 1.\n\nvar check = require(\"users/jhowarth/eePatterns:checks/t01.js\");\n\n//  Uncomment the four lines below, run script, and look at the results in Console. \n\n// print(\"QUANTITATIVE CHECKS:\");\n// check.checkPoint(\"CP1:\", image);\n// check.checkPoint(\"CP2:\", image_meters);\n// check.checkPoint(\"CP3:\", image_slope);\n\n//  II. QUALITATIVE  \n\n//  Use zoom to inspect locations marked A, B, C, D.\n//  For each letter, please write down:\n\n//    1. What do you think the location \"is\"?\n//    2. How does the location represent environmental change?\n\n//  We will discuss in next lecture. \n</code></pre> <p>This work is licensed under CC BY-NC-SA 4.0</p>"},{"location":"tutorials/02/","title":"a slippy topographic map of the USA","text":""},{"location":"tutorials/02/#goal","title":"goal","text":"<p>In this tutorial, our practical goal is to import a digital elevation model (DEM) from this address:</p> <pre><code>'USGS/3DEP/10m'\n</code></pre> <p>and make a map with the layers shown below.  </p> <p> </p> <p>open app in new tab</p>"},{"location":"tutorials/02/#starter-script","title":"starter script","text":"<pre><code>// Require geo module. \n\nvar geo = require(\"users/jhowarth/eePatterns:modules/geo.js\"); print(\"geo dictionary\", geo.help);      // Prints dictionary of all tools in module.\nprint(\"geo palettes\", geo.iPalettes);   // Prints dictionary of all palettes in module. \n\n// -------------------------------------------------------------------------------\n//  Area of interest for tutorial.\n// -------------------------------------------------------------------------------\n\nvar aoi = geo.aoi.t2;\n\nprint(\"Area of interest\", aoi);\n\n// -------------------------------------------------------------------------------\n//  MAP\n//\n//  Center map on aoi at zoom level 10. \n//  Set basemap to hybrid.\n// -------------------------------------------------------------------------------\n\n\n\n// -------------------------------------------------------------------------------\n//  DEM\n//\n//  Gather raster from this address: 'USGS/3DEP/10m'\n//  Display the image with stretch enhancement. \n//  Do not show the image by default. \n// -------------------------------------------------------------------------------\n\nvar image ;\n\n// -------------------------------------------------------------------------------\n//  SLOPE\n//\n//  Derive slope of a surface in degrees from elevation in meters from DEM.\n//  Display the image with stretch enhancement. \n// -------------------------------------------------------------------------------\n\nvar image_slope ;\n\n\n// -------------------------------------------------------------------------------\n//  HILLSHADE\n//\n//  Derive hillshade from DEM.\n//  Display as layer. \n// -------------------------------------------------------------------------------\n\nvar image_hs ;\n\n// -------------------------------------------------------------------------------\n//  ASPECT\n//\n//  Derive aspect from DEM.\n//  Display image as pseudo-color layer with palette: geo.iPalettes.iAspect.cyclical\n//  Add legend aspect image (continuous data) to 'bottom-left' of Map.\n//  Do not show the image by default. \n// -------------------------------------------------------------------------------\n\nvar image_aspect ;\n\n\n// -------------------------------------------------------------------------------\n//  ASPECT, part 2\n//\n//  Make a boolean image where all pixels not equal to 0 are true.\n//  Display boolean image as a map layer.\n//  Do not show the image by default. \n\n//  Mask all pixels in aspect image that are equal to 0.\n//  Display masked image as a map layer. \n//  Do not show the image by default. \n// -------------------------------------------------------------------------------\n\n//  Make a boolean (true/false) image based on a criterion.\n\nvar aspect_neq_0 ;\n\n// -------------------------------------------------------------------------------\n//  ASPECT, part 3\n//\n//  Reclassify the aspect image by equal intervals (22.5).\n//  Remap the image to represent N, NE, E, SE, S, SW, W, NW categories. \n//  Display remapped image as a pseudo-color layer with palette: geo.iPalettes.iAspect.nominal\n//  Add legend to the bottom-left corner of Map.\n// -------------------------------------------------------------------------------\n\n//  Reclassify by equal intervals.\n\nvar image_aspect_reclassified ;\n\n//  Remap values. \n\nvar image_aspect_remapped ;\n\n// -------------------------------------------------------------------------------\n//  ADD AOI ON TOP OF MAP\n// -------------------------------------------------------------------------------\n\nMap.add(geo.aoi.t2_layer);\n</code></pre>"}]}